---
category: Error Handling
topics: [heuristics, project-detection, package-structure, namespace-packages, file-selection]
related: [./wheel-file-selection.md, ./path-validation.md, ./build-validation.md]
---

# Heuristic Failure Handling in Hatchling

## Overview

When helping users diagnose why Hatchling's automatic detection fails, reference this guide to understand and resolve heuristic failures. Hatchling uses heuristics to automatically detect project structure and configuration. When these heuristics fail, explicit configuration is required. This document covers common heuristic failures and their resolutions.

## File Selection Heuristics

### Default Detection Order

Hatchling attempts to detect project structure in this order:

1. **Single Package Directory**

   ```text
   project/
   ├── mypackage/
   │   └── __init__.py
   └── pyproject.toml
   ```

2. **Src-Layout**

   ```text
   project/
   ├── src/
   │   └── mypackage/
   │       └── __init__.py
   └── pyproject.toml
   ```

3. **Single Module**
   ```text
   project/
   ├── mymodule.py
   └── pyproject.toml
   ```

### When Heuristics Fail

**Error Message (v1.19.0+):**

```text
ValueError: At least one file selection option must be defined
```

**Improved Error (v1.22.0+):**

```text
Improve error message for when the default heuristics for wheel
file inclusion fail
```

### Common Failure Scenarios

#### 1. Multiple Top-Level Packages

**Structure:**

```text
project/
├── package1/
│   └── __init__.py
├── package2/
│   └── __init__.py
└── pyproject.toml
```

**Heuristic Failure:** Cannot determine which package to include

**Resolution:**

```toml
[tool.hatch.build.targets.wheel]
packages = ["package1", "package2"]
```

#### 2. Non-Standard Package Names

**Structure:**

```text
project/
├── my_awesome_lib/  # Doesn't match project name
│   └── __init__.py
└── pyproject.toml  # name = "awesome-lib"
```

**Heuristic Failure:** Package directory doesn't match normalized name

**Resolution:**

```toml
[tool.hatch.build.targets.wheel]
packages = ["my_awesome_lib"]
```

#### 3. Mixed Content Types

**Structure:**

```text
project/
├── lib.py
├── utils.py
├── scripts/
├── data/
└── pyproject.toml
```

**Heuristic Failure:** No clear package structure

**Resolution:**

```toml
[tool.hatch.build.targets.wheel]
include = [
    "*.py",
    "scripts/*.py",
    "data/*.json"
]
```

## Package Name Normalization

### Case-Insensitive Filesystem Issues

**Problem (Fixed v1.19.0):**

```text
Project name: My-Package
Directory: my_package/
Filesystem: macOS (case-insensitive)
```

**Heuristic Confusion:** Name mismatch on case-insensitive systems

**Resolution:**

```toml
[project]
name = "my-package"  # PyPI normalized name

[tool.hatch.build.targets.wheel]
packages = ["my_package"]  # Actual directory name
```

### Normalization Rules

```python
def normalize_name(name: str) -> str:
    """PEP 503 normalization."""
    return re.sub(r"[-_.]+", "-", name).lower()

# Examples:
# "My-Package" → "my-package"
# "my_package" → "my-package"
# "My.Package" → "my-package"
```

## Single Module Detection

### Successful Heuristic

**Structure:**

```text
project/
├── myapp.py  # Single module, matches project name
└── pyproject.toml  # name = "myapp"
```

### Failed Heuristic

**Structure:**

```text
project/
├── app.py  # Doesn't match project name
├── utils.py  # Multiple modules
└── pyproject.toml  # name = "myapp"
```

**Resolution:**

```toml
[tool.hatch.build.targets.wheel]
include = ["app.py", "utils.py"]
# or
py-modules = ["app", "utils"]
```

## Namespace Package Detection

### Heuristic Limitations

**Structure:**

```text
project/
├── src/
│   └── company/  # No __init__.py (namespace package)
│       └── project/
│           └── __init__.py
└── pyproject.toml
```

**Heuristic Failure:** Cannot detect namespace package structure

**Resolution:**

```toml
[tool.hatch.build.targets.wheel]
packages = ["src/company"]
# Include namespace package root
```

## Build Hook Artifact Detection

### Generated Files Issue

**Problem:** Files generated by build hooks aren't detected by heuristics

**Example Build Hook:**

```python
class GenerateVersion(BuildHookInterface):
    def initialize(self, version, build_data):
        # Generate version file
        Path("src/package/_version.py").write_text(
            f'__version__ = "{version}"'
        )
```

**Heuristic Issue:** File doesn't exist during initial detection

**Resolution (v1.19.1+):**

```toml
[tool.hatch.build.targets.wheel]
artifacts = ["src/package/_version.py"]
# Build hooks' artifacts count as file selection
```

## Dependency Heuristics

### Broken Distribution Detection

**Issue (Fixed v1.12.0):** Broken dependencies crash build

**Detection Logic:**

```python
def check_dependency(dep):
    try:
        # Attempt to parse dependency
        Requirement(dep)
        return True
    except Exception:
        # Skip broken dependency
        return False
```

### Direct Reference Detection

**Heuristic:** Direct references are disallowed by default

**Example:**

```toml
[project]
dependencies = [
    "package @ git+https://github.com/user/repo.git"
]
```

**Error:** Direct references not allowed

**Override Heuristic:**

```toml
[tool.hatch.metadata]
allow-direct-references = true
```

## Version Detection Heuristics

### Dynamic Version Detection

**Default Heuristic:**

```python
# Looks for __version__ in common locations:
# - src/package/__init__.py
# - src/package/__about__.py
# - src/package/_version.py
# - package/__init__.py
```

**When It Fails:**

```toml
[tool.hatch.version]
path = "src/mypackage/constants.py"  # Non-standard location
pattern = 'VERSION = "{version}"'    # Non-standard variable
```

## Debugging Heuristic Failures

### 1. Diagnostic Script

```python
#!/usr/bin/env python3
"""Diagnose heuristic detection issues."""

from pathlib import Path
import tomllib

def diagnose_heuristics():
    """Check what Hatchling will detect."""
    root = Path.cwd()

    # Load config
    with open("pyproject.toml", "rb") as f:
        config = tomllib.load(f)

    project_name = config["project"]["name"]
    normalized_name = project_name.lower().replace("-", "_")

    print(f"Project name: {project_name}")
    print(f"Normalized: {normalized_name}")

    # Check for standard layouts
    checks = {
        "Single package": root / normalized_name,
        "Src layout": root / "src" / normalized_name,
        "Single module": root / f"{normalized_name}.py",
    }

    detected = []
    for layout, path in checks.items():
        if path.exists():
            print(f"✓ {layout}: {path}")
            detected.append(layout)
        else:
            print(f"✗ {layout}: {path}")

    if not detected:
        print("\n⚠️  No standard layout detected!")
        print("Explicit configuration required in pyproject.toml")

if __name__ == "__main__":
    diagnose_heuristics()
```

### 2. Force Explicit Configuration

```toml
# Disable all heuristics - be explicit
[tool.hatch.build.targets.wheel]
# Explicitly list everything
packages = ["src/mypackage"]
include = ["README.md", "LICENSE"]
exclude = ["tests/**", "docs/**"]

[tool.hatch.build.targets.sdist]
include = ["src", "tests", "docs", "pyproject.toml"]
```

### 3. Validation Before Build

```bash
#!/bin/bash
# Pre-build validation script

echo "Checking build configuration..."

# Test build without actually building
python -c "
from hatchling.builders.wheel import WheelBuilder
from hatchling.metadata.core import ProjectMetadata
from pathlib import Path

root = Path.cwd()
metadata = ProjectMetadata(root, None, {})
builder = WheelBuilder(str(root), metadata=metadata)

try:
    # This will trigger heuristic detection
    files = list(builder.recurse_included_files())
    print(f'✓ Will include {len(files)} files')
except ValueError as e:
    print(f'✗ Heuristic detection failed: {e}')
    exit(1)
"
```

## Best Practices

### 1. Use Standard Layouts

**Recommended: Src-Layout**

```text
project/
├── src/
│   └── package_name/  # Matches project name
│       ├── __init__.py
│       └── modules/
├── tests/
├── docs/
└── pyproject.toml
```

### 2. Be Explicit When Non-Standard

```toml
[tool.hatch.build]
# Document why explicit config is needed
# "Non-standard layout: multiple packages"
packages = ["core", "plugins", "utils"]
```

### 3. Test Heuristic Detection

```python
# test_heuristics.py
def test_package_detection():
    """Ensure package is detectable by heuristics."""
    from hatchling.metadata.core import ProjectMetadata
    from pathlib import Path

    metadata = ProjectMetadata(Path.cwd(), None, {})
    # Should not raise ValueError
    assert metadata.build_config.packages
```

### 4. Document Structure

```markdown
# Project Structure

This project uses a non-standard layout:

- `core/`: Main application package
- `plugins/`: Plugin system
- `shared/`: Shared utilities

Hatchling configuration explicitly lists packages due to non-standard structure.
```

## Migration from Failed Heuristics

### Step 1: Identify Current Structure

```bash
find . -name "*.py" -type f | head -20
find . -name "__init__.py" | head -10
```

### Step 2: Add Explicit Configuration

```toml
[tool.hatch.build.targets.wheel]
# Start with explicit configuration
packages = ["package_name"]

# Then test
# hatch build -t wheel
```

### Step 3: Validate Build Output

```bash
# Check wheel contents
unzip -l dist/*.whl | grep -E "\.py$"
```

## Version History

- **v1.22.0**: Improved heuristic error messages
- **v1.19.1**: Build artifacts count as file selection
- **v1.19.0**: Added validation for file selection
- **v1.11.1**: Fixed single module detection
- **v1.8.1**: Fixed name normalization issues

## Related Documentation

- [Wheel File Selection](./wheel-file-selection.md)
- [Path Validation](./path-validation.md)
- [Build Validation](./build-validation.md)
